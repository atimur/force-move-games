pragma solidity ^0.4.18;

import './CommonState.sol';

library RPSState is CommonState {
  enum StateType { Start, RoundProposed, RoundAccepted, Reveal, Final }
  enum Play { Rock, Paper, Scissors }

  // RockPaperScissors State Fields
  // (relative to gamestate offset)
  // ==============================
  // [  0 -  31] enum stateType
  // [ 32 -  63] uint256 aBal
  // [ 64 -  95] uint256 bBal
  // [ 96 - 127] uint256 stake
  // [128 - 159] bytes32 preCommit
  // [160 - 191] enum bPlay
  // [192 - 223] enum aPlay
  // [224 - 255] bytes32 salt

  function stateType(bytes _state) public returns (StateType _stateType) {
    uint offset = gameStateOffset(_state);
    assembly {
      _stateType := mload(add(_state, offset));
    }
  }

  function aBal(bytes _state) public returns (uint256 _aBal) {
    uint offset = gameStateOffset(_state) + 32;
    assembly {
      _aBal := mload(add(_state, offset));
    }
  }

  function bBal(bytes _state) public returns (uint256 _bBal) {
    uint offset = gameStateOffset(_state) + 64;
    assembly {
      _bBal := mload(add(_state, offset));
    }
  }

  function stake(bytes _state) public returns (uint256 _stake) {
    uint offset = gameStateOffset(_state) + 96;
    assembly {
      _stake := mload(add(_state, offset));
    }
  }
  function preCommit(bytes _state) public returns (bytes32 _preCommit) {
    uint offset = gameStateOffset(_state) + 128;
    assembly {
      _preCommit := mload(add(_state, offset));
    }
  }

  function aPlay(bytes _state) public returns (Play _aPlay) {
    uint offset = gameStateOffset(_state) + 160;
    assembly {
      _aPlay := mload(add(_state, offset));
    }
  }

  function bPlay(bytes _state) public returns (Play _bPlay) {
    uint offset = gameStateOffset(_state) + 192;
    assembly {
      _bPlay := mload(add(_state, offset));
    }
  }

  function salt(bytes _state) public returns (bytes32 _salt) {
    uint offset = gameStateOffset(_state) + 224;
    assembly {
      _salt := mload(add(_state, offset));
    }
  }
}

contract RockPaperScissors {

  using RPSState for bytes;

  struct State {
    StateType stateType;
    uint256 aBal;
    uint256 bBal;
    uint256 stake;
    bytes32 aPreCommit;
    Play bPlay;
    Play aPlay;
    bytes32 aSalt;
  }

  // The following transitions are allowed:
  //
  // Start -> RoundProposed
  // RoundProposed -> Start // reject game
  // RoundProposed -> RoundAccepted
  // RoundAccepted -> Reveal
  // Reveal -> Start
  // Start -> Final
  //
  function validTransition(bytes _old, bytes _new) public pure returns (bool) {
    if (stateType(_old) == StateType.Start) {
      if (stateType(_new) == StateType.RoundProposed) {
        require(stake(_new) > 0);
        require(aBal(_old) >= stake(_new)); // avoid integer overflow attacks
        require(bBal(_old) >= stake(_new)); // avoid integer overflow attacks
        require(aBal(_new) + stake(_new) == aBal(_old)); // stake removed from aBal
        require(bBal(_new) + stake(_new) == bBal(_old)); // stake removed from bBal

        // we should maybe require that aPreCommit isn't empty, but then it will only hurt a later if it is
        return true;
      } else if (newState.stateType == StateType.Final) {
        require(newState.aBal == oldState.aBal);
        require(newState.bBal == oldState.bBal);
        return true;
      }
    } else if (oldState.stateType == StateType.RoundProposed) {
      if (newState.stateType == StateType.Start) { // game rejected
        require(newState.aBal == oldState.stake + oldState.aBal); // stake returned from aBal
        require(newState.bBal == oldState.stake + oldState.bBal); // stake returned from bBal
        return true;
      } else if (newState.stateType == StateType.RoundAccepted) {
        require(newState.aBal == oldState.aBal);
        require(newState.bBal == oldState.bBal);
        require(newState.stake == oldState.stake);
        require(newState.aPreCommit == oldState.aPreCommit);
        return true;
      }
    } else if (oldState.stateType == StateType.RoundAccepted) {
      if (newState.stateType == StateType.Reveal) {
        require(newState.aBal == oldState.aBal);
        require(newState.bBal == oldState.bBal);
        require(newState.stake == oldState.stake);
        require(newState.bPlay == oldState.bPlay);

        // need to convert Play -> uint256 to get hash to work
        bytes32 hashed = keccak256(uint256(newState.aPlay), newState.aSalt);
        require(hashed == oldState.aPreCommit);

        return true;
      }
    } else if (oldState.stateType == StateType.Reveal) {
      if (newState.stateType == StateType.Start) {
        uint256 aWinnings;
        uint256 bWinnings;
        (aWinnings, bWinnings) = winnings(oldState.aPlay, oldState.bPlay, oldState.stake);

        assert(newState.aBal == oldState.aBal + aWinnings);
        assert(newState.bBal == oldState.bBal + bWinnings);

        return true;
      }
    }

    revert();
  }

  // in this case the resolution function is pure, but it doesn't have to be in general
  function resolve(bytes _state) public pure returns (uint aBal, uint bBal) {
    State memory state = unpack(_state);

    if (state.stateType == StateType.Start) {
      aBal = state.aBal;
      bBal = state.bBal;
    } else if (state.stateType == StateType.Final) {
      aBal = state.aBal;
      bBal = state.bBal;
    } else if (state.stateType == StateType.RoundProposed) {
      aBal = state.aBal + state.stake;
      bBal = state.bBal + state.stake;
    } else if (state.stateType == StateType.RoundAccepted) {
      // if we're stuck here, assume a doesn't want to move
      // TODO: how do we know it's a's move ...
      aBal = state.aBal;
      bBal = state.bBal + 2 * state.stake;
    } else if (state.stateType == StateType.Reveal) {
      // in this state we need to know who won
      uint256 aWinnings;
      uint256 bWinnings;
      (aWinnings, bWinnings) = winnings(state.aPlay, state.bPlay, state.stake);

      aBal = state.aBal + aWinnings;
      bBal = state.bBal + bWinnings;
    } else {
      revert();
    }
  }

  function winnings(Play firstPlay, Play secondPlay, uint256 stake) private pure returns (uint256, uint256) {
      if (firstPlay == secondPlay) { // no-one won
        return (stake, stake);
      } else if ((firstPlay == Play.Rock && secondPlay == Play.Scissors) ||
                 (firstPlay > secondPlay)) { // first player won
        return (2 * stake, 0);
      } else { // second player won
        return (0, 2 * stake);
      }
  }

}
